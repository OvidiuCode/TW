Demonstrația ca programare
Introducere
Validarea codului prin însoţirea de demonstraţii (VCD) este un mecanism software ce permite ca un sistem gazdă să verifice proprietăţile unei aplicaţii cu ajutorul unei demonstraţii ce insoţeşte codul executabil al aplicaţiei respective. Sistemul gazdă poate compara concluziile demonstraţiei cu poliţa de siguranţă proprie pentru a determina dacă aplicaţia poate fi executată în mod protejat. Acest lucru poate fi folositor pentru asigurarea siguranţei memoriei, ca de exemplu prevenirea overflow-urilor de buffer si alte vulnerabilităţi comune în unele limbaje de programare.
Validarea codului prin însoţirea de demonstraţii (VCD) este o tehnică ce poate fi utilizată pentru executarea în mod protejat a codului nesigur. Într-o utilizare tipică a VCD, sistemul gazdă stabileşte un set de reguli de securitate ce garantează comportamentul sigur al programelor, iar producatorul codului creează o demonstraţie de siguranţă ce dovedeşte, pentru codul nesigur, aderenţa la regulile de securitate. Apoi, sistemul gazdă poate utiliza un validator de demonstraţii simplu si rapid, pentru a verifica, cu certitudine, că demonstraţia este validă şi, implicit, codul poate fi executat în siguranţă.
Avantajele utilizării VCD:
 Chiar dacă se impune un efort mai mare in stabilirea şi demonstrarea siguranţei codului, aproape intreaga povară cade pe umerii producătorului codului. Pe de altă parte, cel ce utilizează codul nu trebuie decât să execute un proces de verificare a demonstraţiilor rapid, simplu, şi demn de incredere.
 Utilizatorul codului nu are nevoie să ştie cum au fost construite demonstraţiile. Indiferent cum au fost acestea construite, este de asemenea un important avantaj faptul că utilizatorul nu are nevoie să se increadă în procesul de generare a demonstraţiilor.
 Programele VCD sunt “tamperproof”, adică orice modificare, (accidentală sau răuvoitoare) are trei rezultate posibile: (1) demonstraţia nu va mai fi validă şi drept urmare programul va fi respins, (2) demonstraţia va fi validă, dar nu va fi una sigură pentru program şi din nou acesta va fi respins, sau (3) demonstraţia va fi validă şi va fi sigură pentru program, in ciuda modificărilor făcute. În cel de-al treilea caz, chiar dacă, comportamentul programului ar putea fi schimbat, garanţia siguranţei încă va exista.
 Datorită faptului că, codul nesigur este verificat static, înainte de a fi executat, nu numai că se face economie de timp la execuţie, dar pot fi detectate din timp potenţiale operaţii riscante, astfel evitându-se situaţiile în care utilizatorul codului trebuie să distrugă procesele nesigure după ce a procurat resursele sau stările modificate.
Dificultăţi tehnice ce trebuie depăşite:
Ideea validării codului prin însoţirea de demonstraţii este uşor de înteles dar mult mai dificil de implementat. Unele dintre obstacolele ce trebuie depăşite sunt următoarele:
 cum să se transpună demonstratia propriu-zisă in cod? Codificarea demonstraţiilor proprietăţilor programelor este de foarte mari dimensiuni.
 cum să se verifice demonstraţia? Aceasta nu este o sarcină prea uşoară dacă se vrea ca demonstraţiile să fie concise iar verificatorul să fie mic, rapid şi in marea majoritate independent de actuala poliţă de siguranţă care este impusă.
 cum să se facă legătura între demonstraţie şi program? Degeaba se face validarea demonstraţiei dacă nu se poate asigura că aceasta este făcută cu referire la programul respectiv.
Implementarea VCD
O implementare tipică a VCD conţine următoarele 5 elemente:
 Un limbaj formal de specificare folosit pentru a exprima poliţa de siguranţă.
 O semantică formală a limbajului folosit de codul nesigur.
 Un limbaj folosit pentru a exprima demonstraţiile.
 Un algoritm pentru validarea demonstraţiilor.
 O metodă pentru generarea demonstraţiilor de siguranţă.
Validarea codului prin însoţirea de demonstraţii
Figura urmăoare arată procesul tipic de generare şi folosire a VCD:
Tot procesul este centrat asupra poliţei de siguranţă care este definită şi făcută publică de către codul consumator. Prin această poliţă codul consumator specifică exact în ce condiţii consideră că execuţia unui program străin este sigură. Poliţa de siguranţă are două componente principale: reguli de siguranţă şi interfaţa. Regulile de siguranţă descriu toate operaţiile permise şi precondiţiile de siguranţă asociate. Interfaţa descrie convenţiile de apel între codul consumator şi programul străin.
Execuţia unui VCD binar are trei părţi:
În prima parte - numită certificare - codul producător compilează şi generează o demonstraţie că programul sursă aderă la poliţa de siguranţă. În general, certificarea este, în esenţă, o formă de verificare a programului în concordanţă cu specificaţiile poliţei de siguranţă. În plus este produsă o dovadă a verificării cu succes şi codată corespunzător pentru a îndeplini demonstraţia de siguranţă, care împreună cu codul nativ component alcătuieşte VCD binar. Codul producător reţine VCD binar rezultat pentru folosirea ulterioară sau poate fi trimisă codurilor consumatoare pentru execuţie.
În cea de-a doua parte - numită validare - un cod consumator validează partea de demonstraţie a VCD binar prezentat pentru execuţie şi încarcă componenta cu codul nativ pentru execuţie. Validarea este rapidă şi făcută de un algoritm simplu. Consumatorul trebuie să aibe încredere în acest algoritm şi în poliţa de siguranţă. Existenţa demonstraţiei permite ca verificarea sa fie facută offline şi o singură dată pentru un program dat, indiferent de câte ori este executat. Acest lucru este un avantaj în special în cazul când verificarea este grea şi consumatoare de timp sau necesită intervenţia utilizatorului. În asemenea cazuri ar fi de nedorit ca verificarea să fie facută pe situl consumatorului.
În ultima parte a procesului, codul consumator execută programul cod-maşină posibil de mai multe ori. Această parte poate continua fără a face verificări în timpul execuţiei în plus, deoarece partea anterioară a validării asigură că codul satisface poliţa de siguranţă.
Studii de caz:
Stabilirea Poliţei de Siguranţă
Definirea Poliţei de Siguranţă a sistemului runtime TIL pentru funcţii străine este o treabă pentru designerul de compilator TIL. Poliţa de siguranţă, în cazul nostru, cere codului străin să păstreze invarianţa reprezentării datelor alese de compilatorul TIL. Reprezentarea datelor în TIL este direcţionată pe tipuri. Tipurile implicate în exemplu sunt:
T::= int | T1 * T2 | T list
Pentru convenienţă folosim T ca o abreviere pentru tipul int+ (int*int). În acest subset de tipuri ML, regulile de reprezentare a datelor TIL sunt : un întreg este reprezentat ca un cuvânt maşină pe 32 de biţi fără semn ; o pereche este reprezentată ca un pointer către o secvenţă de două locaţii în memorie care conţine valori de tipuri apropiate; o valoare de tip T1 + T2 este reprezentată ca un pointer către o pereche de locaţii ce conţin valoarea constructorului (0 pentru inj_l şi 1 pentru inj_r) şi valoarea care o conţine constructorul; lista vidă este reprezentată ca valoarea 0 şi lista nevidă ca un pointer la o celulă din listă.
Reprezentarea datelor în TIL. Fiecare căsuţă reprezintă un cuvânt maşină:
Computarea Condiţiei de Verificare
Metoda principală de verificare a conformităţii funcţiei străine cu regulile de siguranţă este o verificare în stil Floyd. Acesta este un predicat cu proprietatea că validitatea ei respectă regulile logicii "first-order" şi regulile de scriere sunt suficiente pentru a asigura conformitatea funcţiei cu poliţa de siguranţă. Ambii, programatorul si cel ce foloseste codul, estimează condiţia de verificare : programatorul cu scopul de a dovedi codul si consumatorul de cod să se asigure că, codul străin este acompaniat de dovadă validă. Pentru a folosi generatorul de condiţii de verificare de tip Floyd, toate structurile repetitive trebuie date la fel ca interfeţele pentru toate funcţiile apelate. Invarianţa asociată cu structura repetitivă incepând la L2 este :
rm |- r0 : T list /\ rm |- r1 : int
şi interfaţa pentru funcţia sum este dată ca precondiţie şi postcondiţie:
Pre ≡ rm |- r0 : T list
Post ≡ rm |- r0 : int
În general, invarianţa repetitivă pentru poliţe de siguranţă este conjuncţia tuturor predicatelor de scriere pentru regiştrii care sunt la punctul de invarianţă. Interfaţele sunt derivate similar din tipurile de funcţii. Pentru flexibilitate, permitem invariaţiile să fie asociate cu puncte arbitrare din program, nu neapărat facând parte din structura repetitivă. Aceste puncte sunt marcate în program de INV pseudo instrucţiuni (în practică invariaţiile sunt păstrate separat de cod, permiţând codului să fie executat direct de procesor) şi setul lor este denotat de Inv. Un astfel de punct i scriem Inv i să denotăm invarianţa corespunzătoare. Generatorul de condiţii de verificare compune un vector VC de predicate, unu pentru fiecare instrucţiune.
Notaţia [e/ri]P reprezintă predicate obţinute din P prin substituirea expresiei e pentru toate apariţiile lui ri. Funcţia VC este bine definită dacă fiecare repetiţie in program conţine cel puţin o instrucţiune invariantă. Sub aceste condiţii întregul vector VC poate fi realizat intr-o trecere prin program. Bazându+ne pe vectorul VC, definim condiţia de verificare pentru întregul program:
VC(Π,Inv,Post) = ri /\VCi+1 în Inv , i € Inv
Predicatul VC are două conjuncţii, una pentru precondiţie si alta pentru invarianţa asociată cu L2. Prima conjuncţie corespunde drumului de la intrarea in funcţie până la inceperea buclei repetitive. A doua Conjuncţie corespunde la restul programului şi spune că invarianţa buclei este păstrată în preajma buclei şi apeleaza postcondiţia când termina bucla.
Siguranţa Certificării cu VC
Predicatul VC, definit mai sus, este dovedit de programator şi o dovadă este poliţa de siguranţă. Scriem ΔP când predicatul P poate fi dovedit folosind regulile de interfaţă şi regulile logicii cu predicate.
Teoremă: Oricare program Π, seturi de invariante ca Inv si postcondiţii ca Post care îndeplinesc Π0= INV Pre, if ΔVC(Π,Inv,Post) şi starea iniţială satisface condiţia Pre, atunci programul citeste doar din locaţii de memorie valide aşa cum sunt definite de regulile tipizării şi dacă se termină face asta intr-o stare care satisface postcondiţia.
Dovezi de siguranţă
Datorită teoremei de mai sus dovada de siguranţă trebuie să fie o codare a derivaţiei ΔVC(Π,Inv,Post). Folosim o codare formată din doua părţi. Prima parte reprezentă predicatul şi dovezile ca obiecte al Edinburgh Logical Framework (LF). În a doua parte codăm obiectele LF intr-un format binar compact, folosit pentru stocarea sau transmiterea către codul consumatorului.
Filtre de pachete sigure
În această parte vom prezenta cum se foloseşte validarea codului prin însoţirea de demonstraţii pentru filtrarea pachetelor într-o reţea.
Multe dintre sistemele de operare moderne oferă o facilitate pentru a permite aplicaţiilor să primească pachete direct de la un nod al reţelei. De obicei o aplicaţie nu e interesată să primească fiecare pachet direct de la reţea, ci doar o fracţiune cu o anumită proprietate. În acest caz, este foarte profitabil să i se permită programului să folosească o funcţie booleană pe pachetele reţelei şi atunci folosind acest filtru în nucleul spaţiului de adrese. Nucleul poate astfel evita trimiterea de pachete nedorite aplicaţiei, astfel economisind costul a numeroase schimbări contextuale inutile. Filtrele de pachete sunt suportate de majoritatea sistemelor de operare din ziua de azi.
Principala problemă tehnică este aceea că aplicaţiile nu sunt de incredere prin moştenire, astfel nucleul trebuie să aibă metode pentru a garanta siguranţa. O soluţie cunoscută este de a defini un limbaj de programare sigur pentru scrierea filtrelor, apoi de a folosi un interpretor în nucleu pentru a le executa. În limbajul BPF, de exemplu, programele filtru trebuie sa aiba un ciclu, şi toate referinţele la memorie sunt verificate în timpul execuţiei pentru a nu depăşi marginile pachetului sau ale memoriei alocate static.
VCD se poate folosi pentru a defini aceeaşi poliţă de siguranţă ca şi BPF, apoi se poate scrie o colecţie de filtre de pachet tipice în limbajul de asamblare. Din moment ce filtrele nu sunt scrise într-un limbaj interpretat, ele sunt de zece ori mai rapide ca cele scrise folosind BPF cu aceeaşi funcţionare. Validările sunt mici, între 300 şi 900 de biţi, iar timpul de validare este neglijabil, între 0.3ms şi 1.3ms.
Generarea demonstraţiilor de siguranţă
Există numeroase discuţii rămase deschise cu privire la generarea demonstraţiilor de siguranţă cum ar fi scalabilitatea la probleme mai complicate. Momentan se pot obţine demonstraţii folosind un validator de teoremă foarte simplu care produce un martor pentru fiecare demonstraţie reuşită. Există şi alte metode care pot funcţiona mai bine în special pentru programe mai mari.
Limbajul de programare Elf este folosit pentru a demonstra predicate VC şi a produce reprezentări LF ale demonstraţiilor. Un program în Elf este o signatură in LF şi execuţia în Elf este căutarea de obiecte canonice LF de având tipul LF în contextul unei signaturi.
Căutarea demonstraţiei in Elf este făcută în adâncime ca şi în Prolog. Cu această viziune operaţională deducerea naturală reprezentată de logica umană nu este potrivită pentru căutarea demonstraţiei deoarece orice regulă de eliminare va duce la neterminare. Soluţia la această problemă se bazează pe observarea faptului că toate predicatele VC sunt fie clauze Horn, fie
formule ereditare Harrop. Demonstraţiile rezultate se numesc uniforme. Reprezentarea LF a unui sistem uniform de demonstraţii poate fi folosită ca un program logic pentru a face o căutare a demonstraţiilor.
În LF se reprezintă regulile de derivare uniforme într-o manieră similară cu reprezentare deducţiei naturale. Această reprezentare e folosită în Elf pentru a face o căutare orientată spre rezultat pentru o derivare uniformă a validităţii predicatului VC. În LF este reprezentată demonstraţia solidităţii derivărilor uniforme conform cu deducţia naturală. Citirea operaţională a demontraţiei în Elf este folosită pentru a converti derivaţia uniformă a predicatului VC într-o deducţie naturală a sa.
Fiecare signatură LF, derivaţiile uniforme ale demonstraţiei pentru acestea şi soliditatea demonstraţiilor uniforme constau în aproximativ 15 declaraţii de constante.
Concluzii
Validarea codului prin însoţirea de demonstraţii este un mecanism care îi permite consumatorului să interacţioneze în siguranţă cu un cod nativ pus la dispoziţie de producători de cod nesiguri. VCD nu modifică overheadul soluţiilor problemei găsite anterior execuţiei. În schimb producătorul de cod trebuie să genereze o demonstraţie care atestă proprietăţile de siguranţă ale codului. Nucleul poate să verifice uşor demonstraţiile de validitate. Mai mult de atât VCD binar nu poate fi alterat; orice încercare de modificare a codului nativ e fie detectată, fie inofensivă conform cu poliţa de siguranţă.
Principala contribuţie este principiul punerii în scenă a verificării programului cu certificarea şi validarea demonstraţiei jucând rolul de martori că certificare s-a făcut corect. Această punere în scenă are mari avantaje bazate pe intuiţia că verificarea demonstraţiei este mai grea decât generarea acesteia.
Aplicaţia, strategii de verificare specifice, căutare orientată spre un obiectiv, demostraţia interactivă de teoremă sau doar căutarea brută prin algoritmi euristici, complexităţile şi costurile computaţionale ale acestora sunt mutate in offline pe scena certificării. Scena validării are nevoie doar de o verificare a demonstraţiei de încredere care în multe cazuri e destul de puţin costisitoare ca să fie folosită în puncte critice. Certificarea trebuie să fie făcută o singură dată indiferent de câte ori e folosit codul.
Verificarea siguranţei tipurilor limbajului de asamblare este la fel de importantă pentru extensii sigure ale limbajelor de programare şi ca un punct solid în construirea compilatoarelor de certificare. Tehnici similare au fost atribuite limbajului de asamblare dar nici una nu a fost o bază pentru crearea demonstraţiilor de siguranţă nici pentru verificarea siguranţei tipurilor.
Validarea codului prin însoţirea de demonstraţii este o aplicare de idei de la verificarea programului, logica şi teoria tipurilor. Tehnicile prezentate sunt folositoare atât pentru limbajele de programare cât şi pentru componentele sistemului de operare. Odată cu creşterea interesului în procese distribuite de nivel înalt, procese web, nuclee extensibile este clară ideea că limbajele de programare sunt destinate să devină critice pentru sisteme performante şi robuste.